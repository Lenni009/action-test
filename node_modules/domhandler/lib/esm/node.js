import{ElementType,isTag as isTagRaw}from"domelementtype";export class Node{constructor(){this.parent=null,this.prev=null,this.next=null,this.startIndex=null,this.endIndex=null}get parentNode(){return this.parent}set parentNode(e){this.parent=e}get previousSibling(){return this.prev}set previousSibling(e){this.prev=e}get nextSibling(){return this.next}set nextSibling(e){this.next=e}cloneNode(e=!1){return cloneNode(this,e)}}export class DataNode extends Node{constructor(e){super(),this.data=e}get nodeValue(){return this.data}set nodeValue(e){this.data=e}}export class Text extends DataNode{constructor(){super(...arguments),this.type=ElementType.Text}get nodeType(){return 3}}export class Comment extends DataNode{constructor(){super(...arguments),this.type=ElementType.Comment}get nodeType(){return 8}}export class ProcessingInstruction extends DataNode{constructor(e,t){super(t),this.name=e,this.type=ElementType.Directive}get nodeType(){return 1}}export class NodeWithChildren extends Node{constructor(e){super(),this.children=e}get firstChild(){var e;return null!==(e=this.children[0])&&void 0!==e?e:null}get lastChild(){return this.children.length>0?this.children[this.children.length-1]:null}get childNodes(){return this.children}set childNodes(e){this.children=e}}export class CDATA extends NodeWithChildren{constructor(){super(...arguments),this.type=ElementType.CDATA}get nodeType(){return 4}}export class Document extends NodeWithChildren{constructor(){super(...arguments),this.type=ElementType.Root}get nodeType(){return 9}}export class Element extends NodeWithChildren{constructor(e,t,n=[],r=("script"===e?ElementType.Script:"style"===e?ElementType.Style:ElementType.Tag)){super(n),this.name=e,this.attribs=t,this.type=r}get nodeType(){return 1}get tagName(){return this.name}set tagName(e){this.name=e}get attributes(){return Object.keys(this.attribs).map((e=>{var t,n;return{name:e,value:this.attribs[e],namespace:null===(t=this["x-attribsNamespace"])||void 0===t?void 0:t[e],prefix:null===(n=this["x-attribsPrefix"])||void 0===n?void 0:n[e]}}))}}export function isTag(e){return isTagRaw(e)}export function isCDATA(e){return e.type===ElementType.CDATA}export function isText(e){return e.type===ElementType.Text}export function isComment(e){return e.type===ElementType.Comment}export function isDirective(e){return e.type===ElementType.Directive}export function isDocument(e){return e.type===ElementType.Root}export function hasChildren(e){return Object.prototype.hasOwnProperty.call(e,"children")}export function cloneNode(e,t=!1){let n;if(isText(e))n=new Text(e.data);else if(isComment(e))n=new Comment(e.data);else if(isTag(e)){const r=t?cloneChildren(e.children):[],s=new Element(e.name,{...e.attribs},r);r.forEach((e=>e.parent=s)),null!=e.namespace&&(s.namespace=e.namespace),e["x-attribsNamespace"]&&(s["x-attribsNamespace"]={...e["x-attribsNamespace"]}),e["x-attribsPrefix"]&&(s["x-attribsPrefix"]={...e["x-attribsPrefix"]}),n=s}else if(isCDATA(e)){const r=t?cloneChildren(e.children):[],s=new CDATA(r);r.forEach((e=>e.parent=s)),n=s}else if(isDocument(e)){const r=t?cloneChildren(e.children):[],s=new Document(r);r.forEach((e=>e.parent=s)),e["x-mode"]&&(s["x-mode"]=e["x-mode"]),n=s}else{if(!isDirective(e))throw new Error(`Not implemented yet: ${e.type}`);{const t=new ProcessingInstruction(e.name,e.data);null!=e["x-name"]&&(t["x-name"]=e["x-name"],t["x-publicId"]=e["x-publicId"],t["x-systemId"]=e["x-systemId"]),n=t}}return n.startIndex=e.startIndex,n.endIndex=e.endIndex,null!=e.sourceCodeLocation&&(n.sourceCodeLocation=e.sourceCodeLocation),n}function cloneChildren(e){const t=e.map((e=>cloneNode(e,!0)));for(let e=1;e<t.length;e++)t[e].prev=t[e-1],t[e-1].next=t[e];return t}
