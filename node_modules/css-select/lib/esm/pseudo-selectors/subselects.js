import boolbase from"boolbase";import{isTraversal}from"../sort.js";export const PLACEHOLDER_ELEMENT={};export function ensureIsTag(e,s){return e===boolbase.falseFunc?boolbase.falseFunc:o=>s.isTag(o)&&e(o)}export function getNextSiblings(e,s){const o=s.getSiblings(e);if(o.length<=1)return[];const t=o.indexOf(e);return t<0||t===o.length-1?[]:o.slice(t+1).filter(s.isTag)}function copyOptions(e){return{xmlMode:!!e.xmlMode,lowerCaseAttributeNames:!!e.lowerCaseAttributeNames,lowerCaseTags:!!e.lowerCaseTags,quirksMode:!!e.quirksMode,cacheResults:!!e.cacheResults,pseudos:e.pseudos,adapter:e.adapter,equals:e.equals}}const is=(e,s,o,t,n)=>{const r=n(s,copyOptions(o),t);return r===boolbase.trueFunc?e:r===boolbase.falseFunc?boolbase.falseFunc:s=>r(s)&&e(s)};export const subselects={is:is,matches:is,where:is,not(e,s,o,t,n){const r=n(s,copyOptions(o),t);return r===boolbase.falseFunc?e:r===boolbase.trueFunc?boolbase.falseFunc:s=>!r(s)&&e(s)},has(e,s,o,t,n){const{adapter:r}=o,a=copyOptions(o);a.relativeSelector=!0;const l=s.some((e=>e.some(isTraversal)))?[PLACEHOLDER_ELEMENT]:void 0,i=n(s,a,l);if(i===boolbase.falseFunc)return boolbase.falseFunc;const u=ensureIsTag(i,r);if(l&&i!==boolbase.trueFunc){const{shouldTestNextSiblings:s=!1}=i;return o=>{if(!e(o))return!1;l[0]=o;const t=r.getChildren(o),n=s?[...t,...getNextSiblings(o,r)]:t;return r.existsOne(u,n)}}return s=>e(s)&&r.existsOne(u,r.getChildren(s))}};
